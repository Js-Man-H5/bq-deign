{
    "resolvedId": "/Users/haixiaonan/Desktop/test/vue3/bq-design/node_modules/.pnpm/vite@5.2.10_@types+node@20.5.1_less@4.2.0_sass@1.77.2/node_modules/vite/dist/client/client.mjs",
    "transforms": [
        {
            "name": "__load__",
            "result": "import '@vite/env';\n\nclass HMRContext {\n    constructor(hmrClient, ownerPath) {\n        this.hmrClient = hmrClient;\n        this.ownerPath = ownerPath;\n        if (!hmrClient.dataMap.has(ownerPath)) {\n            hmrClient.dataMap.set(ownerPath, {});\n        }\n        // when a file is hot updated, a new context is created\n        // clear its stale callbacks\n        const mod = hmrClient.hotModulesMap.get(ownerPath);\n        if (mod) {\n            mod.callbacks = [];\n        }\n        // clear stale custom event listeners\n        const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n        if (staleListeners) {\n            for (const [event, staleFns] of staleListeners) {\n                const listeners = hmrClient.customListenersMap.get(event);\n                if (listeners) {\n                    hmrClient.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n                }\n            }\n        }\n        this.newListeners = new Map();\n        hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n    }\n    get data() {\n        return this.hmrClient.dataMap.get(this.ownerPath);\n    }\n    accept(deps, callback) {\n        if (typeof deps === 'function' || !deps) {\n            // self-accept: hot.accept(() => {})\n            this.acceptDeps([this.ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n        }\n        else if (typeof deps === 'string') {\n            // explicit deps\n            this.acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        }\n        else if (Array.isArray(deps)) {\n            this.acceptDeps(deps, callback);\n        }\n        else {\n            throw new Error(`invalid hot.accept() usage.`);\n        }\n    }\n    // export names (first arg) are irrelevant on the client side, they're\n    // extracted in the server for propagation\n    acceptExports(_, callback) {\n        this.acceptDeps([this.ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n    }\n    dispose(cb) {\n        this.hmrClient.disposeMap.set(this.ownerPath, cb);\n    }\n    prune(cb) {\n        this.hmrClient.pruneMap.set(this.ownerPath, cb);\n    }\n    // Kept for backward compatibility (#11036)\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    decline() { }\n    invalidate(message) {\n        this.hmrClient.notifyListeners('vite:invalidate', {\n            path: this.ownerPath,\n            message,\n        });\n        this.send('vite:invalidate', { path: this.ownerPath, message });\n        this.hmrClient.logger.debug(`[vite] invalidate ${this.ownerPath}${message ? `: ${message}` : ''}`);\n    }\n    on(event, cb) {\n        const addToMap = (map) => {\n            const existing = map.get(event) || [];\n            existing.push(cb);\n            map.set(event, existing);\n        };\n        addToMap(this.hmrClient.customListenersMap);\n        addToMap(this.newListeners);\n    }\n    off(event, cb) {\n        const removeFromMap = (map) => {\n            const existing = map.get(event);\n            if (existing === undefined) {\n                return;\n            }\n            const pruned = existing.filter((l) => l !== cb);\n            if (pruned.length === 0) {\n                map.delete(event);\n                return;\n            }\n            map.set(event, pruned);\n        };\n        removeFromMap(this.hmrClient.customListenersMap);\n        removeFromMap(this.newListeners);\n    }\n    send(event, data) {\n        this.hmrClient.messenger.send(JSON.stringify({ type: 'custom', event, data }));\n    }\n    acceptDeps(deps, callback = () => { }) {\n        const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n            id: this.ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n    }\n}\nclass HMRMessenger {\n    constructor(connection) {\n        this.connection = connection;\n        this.queue = [];\n    }\n    send(message) {\n        this.queue.push(message);\n        this.flush();\n    }\n    flush() {\n        if (this.connection.isReady()) {\n            this.queue.forEach((msg) => this.connection.send(msg));\n            this.queue = [];\n        }\n    }\n}\nclass HMRClient {\n    constructor(logger, connection, \n    // This allows implementing reloading via different methods depending on the environment\n    importUpdatedModule) {\n        this.logger = logger;\n        this.importUpdatedModule = importUpdatedModule;\n        this.hotModulesMap = new Map();\n        this.disposeMap = new Map();\n        this.pruneMap = new Map();\n        this.dataMap = new Map();\n        this.customListenersMap = new Map();\n        this.ctxToListenersMap = new Map();\n        this.updateQueue = [];\n        this.pendingUpdateQueue = false;\n        this.messenger = new HMRMessenger(connection);\n    }\n    async notifyListeners(event, data) {\n        const cbs = this.customListenersMap.get(event);\n        if (cbs) {\n            await Promise.allSettled(cbs.map((cb) => cb(data)));\n        }\n    }\n    clear() {\n        this.hotModulesMap.clear();\n        this.disposeMap.clear();\n        this.pruneMap.clear();\n        this.dataMap.clear();\n        this.customListenersMap.clear();\n        this.ctxToListenersMap.clear();\n    }\n    // After an HMR update, some modules are no longer imported on the page\n    // but they may have left behind side effects that need to be cleaned up\n    // (.e.g style injections)\n    async prunePaths(paths) {\n        await Promise.all(paths.map((path) => {\n            const disposer = this.disposeMap.get(path);\n            if (disposer)\n                return disposer(this.dataMap.get(path));\n        }));\n        paths.forEach((path) => {\n            const fn = this.pruneMap.get(path);\n            if (fn) {\n                fn(this.dataMap.get(path));\n            }\n        });\n    }\n    warnFailedUpdate(err, path) {\n        if (!err.message.includes('fetch')) {\n            this.logger.error(err);\n        }\n        this.logger.error(`[hmr] Failed to reload ${path}. ` +\n            `This could be due to syntax errors or importing non-existent ` +\n            `modules. (see errors above)`);\n    }\n    /**\n     * buffer multiple hot updates triggered by the same src change\n     * so that they are invoked in the same order they were sent.\n     * (otherwise the order may be inconsistent because of the http request round trip)\n     */\n    async queueUpdate(payload) {\n        this.updateQueue.push(this.fetchUpdate(payload));\n        if (!this.pendingUpdateQueue) {\n            this.pendingUpdateQueue = true;\n            await Promise.resolve();\n            this.pendingUpdateQueue = false;\n            const loading = [...this.updateQueue];\n            this.updateQueue = [];\n            (await Promise.all(loading)).forEach((fn) => fn && fn());\n        }\n    }\n    async fetchUpdate(update) {\n        const { path, acceptedPath } = update;\n        const mod = this.hotModulesMap.get(path);\n        if (!mod) {\n            // In a code-splitting project,\n            // it is common that the hot-updating module is not loaded yet.\n            // https://github.com/vitejs/vite/issues/721\n            return;\n        }\n        let fetchedModule;\n        const isSelfUpdate = path === acceptedPath;\n        // determine the qualified callbacks before we re-import the modules\n        const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n        if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n            const disposer = this.disposeMap.get(acceptedPath);\n            if (disposer)\n                await disposer(this.dataMap.get(acceptedPath));\n            try {\n                fetchedModule = await this.importUpdatedModule(update);\n            }\n            catch (e) {\n                this.warnFailedUpdate(e, acceptedPath);\n            }\n        }\n        return () => {\n            for (const { deps, fn } of qualifiedCallbacks) {\n                fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n            }\n            const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n            this.logger.debug(`[vite] hot updated: ${loggedPath}`);\n        };\n    }\n}\n\nconst hmrConfigName = __HMR_CONFIG_NAME__;\nconst base$1 = __BASE__ || '/';\n// Create an element with provided attributes and optional children\nfunction h(e, attrs = {}, ...children) {\n    const elem = document.createElement(e);\n    for (const [k, v] of Object.entries(attrs)) {\n        elem.setAttribute(k, v);\n    }\n    elem.append(...children);\n    return elem;\n}\n// set :host styles to make playwright detect the element as visible\nconst templateStyle = /*css*/ `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\n// Error Template\nconst createTemplate = () => h('div', { class: 'backdrop', part: 'backdrop' }, h('div', { class: 'window', part: 'window' }, h('pre', { class: 'message', part: 'message' }, h('span', { class: 'plugin', part: 'plugin' }), h('span', { class: 'message-body', part: 'message-body' })), h('pre', { class: 'file', part: 'file' }), h('pre', { class: 'frame', part: 'frame' }), h('pre', { class: 'stack', part: 'stack' }), h('div', { class: 'tip', part: 'tip' }, 'Click outside, press ', h('kbd', {}, 'Esc'), ' key, or fix the code to dismiss.', h('br'), 'You can also disable this overlay by setting ', h('code', { part: 'config-option-name' }, 'server.hmr.overlay'), ' to ', h('code', { part: 'config-option-value' }, 'false'), ' in ', h('code', { part: 'config-file-name' }, hmrConfigName), '.')), h('style', {}, templateStyle));\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.appendChild(createTemplate());\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n        this.closeOnEsc = (e) => {\n            if (e.key === 'Escape' || e.code === 'Escape') {\n                this.close();\n            }\n        };\n        document.addEventListener('keydown', this.closeOnEsc);\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n        document.removeEventListener('keydown', this.closeOnEsc);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nvar _a;\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = __SERVER_HOST__;\nconst socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = __HMR_PORT__;\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${__HMR_BASE__}`;\nconst directSocketHost = __HMR_DIRECT_TARGET__;\nconst base = __BASE__ || '/';\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n        notifyListeners('vite:ws:connect', { webSocket: socket });\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        notifyListeners('vite:ws:disconnect', { webSocket: socket });\n        if (hasDocument) {\n            console.log(`[vite] server connection lost. polling for restart...`);\n            await waitForSuccessfulPing(protocol, hostAndPath);\n            location.reload();\n        }\n    });\n    return socket;\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, 'http://vitejs.dev');\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nconst debounceReload = (time) => {\n    let timer;\n    return () => {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n        timer = setTimeout(() => {\n            location.reload();\n        }, time);\n    };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(console, {\n    isReady: () => socket && socket.readyState === 1,\n    send: (message) => socket.send(message),\n}, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport, }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n    /* @vite-ignore */\n    base +\n        acceptedPathWithoutQuery.slice(1) +\n        `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n    if (isWithinCircularImport) {\n        importPromise.catch(() => {\n            console.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. ` +\n                `To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n            pageReload();\n        });\n    }\n    return await importPromise;\n});\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            hmrClient.messenger.flush();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, __HMR_TIMEOUT__);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            if (hasDocument) {\n                // if this is the first update and there's already an error overlay, it\n                // means the page opened with existing server compile error and the whole\n                // module script failed to load (since one of the nested imports is 500).\n                // in this case a normal update won't work and a full reload is needed.\n                if (isFirstUpdate && hasErrorOverlay()) {\n                    window.location.reload();\n                    return;\n                }\n                else {\n                    if (enableOverlay) {\n                        clearErrorOverlay();\n                    }\n                    isFirstUpdate = false;\n                }\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return hmrClient.queueUpdate(update);\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (hasDocument) {\n                if (payload.path && payload.path.endsWith('.html')) {\n                    // if html file is edited, only reload the page if the browser is\n                    // currently on that page.\n                    const pagePath = decodeURI(location.pathname);\n                    const payloadPath = base + payload.path.slice(1);\n                    if (pagePath === payloadPath ||\n                        payload.path === '/index.html' ||\n                        (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                        pageReload();\n                    }\n                    return;\n                }\n                else {\n                    pageReload();\n                }\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            await hmrClient.prunePaths(payload.paths);\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            if (hasDocument) {\n                const err = payload.err;\n                if (enableOverlay) {\n                    createErrorOverlay(err);\n                }\n                else {\n                    console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n                }\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    hmrClient.notifyListeners(event, data);\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nconst hasDocument = 'document' in globalThis;\nfunction createErrorOverlay(err) {\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    const ping = async () => {\n        // A fetch on a websocket URL will return a successful promise with status 400,\n        // but will reject a networking error.\n        // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n        try {\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n                headers: {\n                    // Custom headers won't be included in a request with no-cors so (ab)use one of the\n                    // safelisted headers to identify the ping request\n                    Accept: 'text/x-vite-ping',\n                },\n            });\n            return true;\n        }\n        catch { }\n        return false;\n    };\n    if (await ping()) {\n        return;\n    }\n    await wait(ms);\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (document.visibilityState === 'visible') {\n            if (await ping()) {\n                break;\n            }\n            await wait(ms);\n        }\n        else {\n            await waitForWindowShow();\n        }\n    }\n}\nfunction wait(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n    return new Promise((resolve) => {\n        const onChange = async () => {\n            if (document.visibilityState === 'visible') {\n                resolve();\n                document.removeEventListener('visibilitychange', onChange);\n            }\n        };\n        document.addEventListener('visibilitychange', onChange);\n    });\n}\nconst sheetsMap = new Map();\n// collect existing style elements that may have been inserted during SSR\n// to avoid FOUC or duplicate styles\nif ('document' in globalThis) {\n    document\n        .querySelectorAll('style[data-vite-dev-id]')\n        .forEach((el) => {\n        sheetsMap.set(el.getAttribute('data-vite-dev-id'), el);\n    });\n}\nconst cspNonce = 'document' in globalThis\n    ? (_a = document.querySelector('meta[property=csp-nonce]')) === null || _a === void 0 ? void 0 : _a.nonce\n    : undefined;\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (cspNonce) {\n            style.setAttribute('nonce', cspNonce);\n        }\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nfunction createHotContext(ownerPath) {\n    return new HMRContext(hmrClient, ownerPath);\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (url[0] !== '.' && url[0] !== '/') {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/[?#].*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n                                   \n",
            "start": 1725009516163,
            "end": 1725009516163
        },
        {
            "name": "vite:css",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:esbuild",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:json",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:worker",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:vue",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:define",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:css-post",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:worker-import-meta-url",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:asset-import-meta-url",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:dynamic-import-vars",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:import-glob",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "unplugin-auto-import",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "post"
        },
        {
            "name": "unplugin-vue-components",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "post"
        },
        {
            "name": "vite:client-inject",
            "result": "import '@vite/env';\n\nclass HMRContext {\n    constructor(hmrClient, ownerPath) {\n        this.hmrClient = hmrClient;\n        this.ownerPath = ownerPath;\n        if (!hmrClient.dataMap.has(ownerPath)) {\n            hmrClient.dataMap.set(ownerPath, {});\n        }\n        // when a file is hot updated, a new context is created\n        // clear its stale callbacks\n        const mod = hmrClient.hotModulesMap.get(ownerPath);\n        if (mod) {\n            mod.callbacks = [];\n        }\n        // clear stale custom event listeners\n        const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n        if (staleListeners) {\n            for (const [event, staleFns] of staleListeners) {\n                const listeners = hmrClient.customListenersMap.get(event);\n                if (listeners) {\n                    hmrClient.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n                }\n            }\n        }\n        this.newListeners = new Map();\n        hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n    }\n    get data() {\n        return this.hmrClient.dataMap.get(this.ownerPath);\n    }\n    accept(deps, callback) {\n        if (typeof deps === 'function' || !deps) {\n            // self-accept: hot.accept(() => {})\n            this.acceptDeps([this.ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n        }\n        else if (typeof deps === 'string') {\n            // explicit deps\n            this.acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        }\n        else if (Array.isArray(deps)) {\n            this.acceptDeps(deps, callback);\n        }\n        else {\n            throw new Error(`invalid hot.accept() usage.`);\n        }\n    }\n    // export names (first arg) are irrelevant on the client side, they're\n    // extracted in the server for propagation\n    acceptExports(_, callback) {\n        this.acceptDeps([this.ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n    }\n    dispose(cb) {\n        this.hmrClient.disposeMap.set(this.ownerPath, cb);\n    }\n    prune(cb) {\n        this.hmrClient.pruneMap.set(this.ownerPath, cb);\n    }\n    // Kept for backward compatibility (#11036)\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    decline() { }\n    invalidate(message) {\n        this.hmrClient.notifyListeners('vite:invalidate', {\n            path: this.ownerPath,\n            message,\n        });\n        this.send('vite:invalidate', { path: this.ownerPath, message });\n        this.hmrClient.logger.debug(`[vite] invalidate ${this.ownerPath}${message ? `: ${message}` : ''}`);\n    }\n    on(event, cb) {\n        const addToMap = (map) => {\n            const existing = map.get(event) || [];\n            existing.push(cb);\n            map.set(event, existing);\n        };\n        addToMap(this.hmrClient.customListenersMap);\n        addToMap(this.newListeners);\n    }\n    off(event, cb) {\n        const removeFromMap = (map) => {\n            const existing = map.get(event);\n            if (existing === undefined) {\n                return;\n            }\n            const pruned = existing.filter((l) => l !== cb);\n            if (pruned.length === 0) {\n                map.delete(event);\n                return;\n            }\n            map.set(event, pruned);\n        };\n        removeFromMap(this.hmrClient.customListenersMap);\n        removeFromMap(this.newListeners);\n    }\n    send(event, data) {\n        this.hmrClient.messenger.send(JSON.stringify({ type: 'custom', event, data }));\n    }\n    acceptDeps(deps, callback = () => { }) {\n        const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n            id: this.ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n    }\n}\nclass HMRMessenger {\n    constructor(connection) {\n        this.connection = connection;\n        this.queue = [];\n    }\n    send(message) {\n        this.queue.push(message);\n        this.flush();\n    }\n    flush() {\n        if (this.connection.isReady()) {\n            this.queue.forEach((msg) => this.connection.send(msg));\n            this.queue = [];\n        }\n    }\n}\nclass HMRClient {\n    constructor(logger, connection, \n    // This allows implementing reloading via different methods depending on the environment\n    importUpdatedModule) {\n        this.logger = logger;\n        this.importUpdatedModule = importUpdatedModule;\n        this.hotModulesMap = new Map();\n        this.disposeMap = new Map();\n        this.pruneMap = new Map();\n        this.dataMap = new Map();\n        this.customListenersMap = new Map();\n        this.ctxToListenersMap = new Map();\n        this.updateQueue = [];\n        this.pendingUpdateQueue = false;\n        this.messenger = new HMRMessenger(connection);\n    }\n    async notifyListeners(event, data) {\n        const cbs = this.customListenersMap.get(event);\n        if (cbs) {\n            await Promise.allSettled(cbs.map((cb) => cb(data)));\n        }\n    }\n    clear() {\n        this.hotModulesMap.clear();\n        this.disposeMap.clear();\n        this.pruneMap.clear();\n        this.dataMap.clear();\n        this.customListenersMap.clear();\n        this.ctxToListenersMap.clear();\n    }\n    // After an HMR update, some modules are no longer imported on the page\n    // but they may have left behind side effects that need to be cleaned up\n    // (.e.g style injections)\n    async prunePaths(paths) {\n        await Promise.all(paths.map((path) => {\n            const disposer = this.disposeMap.get(path);\n            if (disposer)\n                return disposer(this.dataMap.get(path));\n        }));\n        paths.forEach((path) => {\n            const fn = this.pruneMap.get(path);\n            if (fn) {\n                fn(this.dataMap.get(path));\n            }\n        });\n    }\n    warnFailedUpdate(err, path) {\n        if (!err.message.includes('fetch')) {\n            this.logger.error(err);\n        }\n        this.logger.error(`[hmr] Failed to reload ${path}. ` +\n            `This could be due to syntax errors or importing non-existent ` +\n            `modules. (see errors above)`);\n    }\n    /**\n     * buffer multiple hot updates triggered by the same src change\n     * so that they are invoked in the same order they were sent.\n     * (otherwise the order may be inconsistent because of the http request round trip)\n     */\n    async queueUpdate(payload) {\n        this.updateQueue.push(this.fetchUpdate(payload));\n        if (!this.pendingUpdateQueue) {\n            this.pendingUpdateQueue = true;\n            await Promise.resolve();\n            this.pendingUpdateQueue = false;\n            const loading = [...this.updateQueue];\n            this.updateQueue = [];\n            (await Promise.all(loading)).forEach((fn) => fn && fn());\n        }\n    }\n    async fetchUpdate(update) {\n        const { path, acceptedPath } = update;\n        const mod = this.hotModulesMap.get(path);\n        if (!mod) {\n            // In a code-splitting project,\n            // it is common that the hot-updating module is not loaded yet.\n            // https://github.com/vitejs/vite/issues/721\n            return;\n        }\n        let fetchedModule;\n        const isSelfUpdate = path === acceptedPath;\n        // determine the qualified callbacks before we re-import the modules\n        const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n        if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n            const disposer = this.disposeMap.get(acceptedPath);\n            if (disposer)\n                await disposer(this.dataMap.get(acceptedPath));\n            try {\n                fetchedModule = await this.importUpdatedModule(update);\n            }\n            catch (e) {\n                this.warnFailedUpdate(e, acceptedPath);\n            }\n        }\n        return () => {\n            for (const { deps, fn } of qualifiedCallbacks) {\n                fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n            }\n            const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n            this.logger.debug(`[vite] hot updated: ${loggedPath}`);\n        };\n    }\n}\n\nconst hmrConfigName = \"vite.config.ts\";\nconst base$1 = \"/\" || '/';\n// Create an element with provided attributes and optional children\nfunction h(e, attrs = {}, ...children) {\n    const elem = document.createElement(e);\n    for (const [k, v] of Object.entries(attrs)) {\n        elem.setAttribute(k, v);\n    }\n    elem.append(...children);\n    return elem;\n}\n// set :host styles to make playwright detect the element as visible\nconst templateStyle = /*css*/ `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\n// Error Template\nconst createTemplate = () => h('div', { class: 'backdrop', part: 'backdrop' }, h('div', { class: 'window', part: 'window' }, h('pre', { class: 'message', part: 'message' }, h('span', { class: 'plugin', part: 'plugin' }), h('span', { class: 'message-body', part: 'message-body' })), h('pre', { class: 'file', part: 'file' }), h('pre', { class: 'frame', part: 'frame' }), h('pre', { class: 'stack', part: 'stack' }), h('div', { class: 'tip', part: 'tip' }, 'Click outside, press ', h('kbd', {}, 'Esc'), ' key, or fix the code to dismiss.', h('br'), 'You can also disable this overlay by setting ', h('code', { part: 'config-option-name' }, 'server.hmr.overlay'), ' to ', h('code', { part: 'config-option-value' }, 'false'), ' in ', h('code', { part: 'config-file-name' }, hmrConfigName), '.')), h('style', {}, templateStyle));\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.appendChild(createTemplate());\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n        this.closeOnEsc = (e) => {\n            if (e.key === 'Escape' || e.code === 'Escape') {\n                this.close();\n            }\n        };\n        document.addEventListener('keydown', this.closeOnEsc);\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n        document.removeEventListener('keydown', this.closeOnEsc);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nvar _a;\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = \"localhost:undefined/\";\nconst socketProtocol = null || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:undefined/\";\nconst base = \"/\" || '/';\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n        notifyListeners('vite:ws:connect', { webSocket: socket });\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        notifyListeners('vite:ws:disconnect', { webSocket: socket });\n        if (hasDocument) {\n            console.log(`[vite] server connection lost. polling for restart...`);\n            await waitForSuccessfulPing(protocol, hostAndPath);\n            location.reload();\n        }\n    });\n    return socket;\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, 'http://vitejs.dev');\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nconst debounceReload = (time) => {\n    let timer;\n    return () => {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n        timer = setTimeout(() => {\n            location.reload();\n        }, time);\n    };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(console, {\n    isReady: () => socket && socket.readyState === 1,\n    send: (message) => socket.send(message),\n}, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport, }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n    /* @vite-ignore */\n    base +\n        acceptedPathWithoutQuery.slice(1) +\n        `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n    if (isWithinCircularImport) {\n        importPromise.catch(() => {\n            console.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. ` +\n                `To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n            pageReload();\n        });\n    }\n    return await importPromise;\n});\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            hmrClient.messenger.flush();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, 30000);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            if (hasDocument) {\n                // if this is the first update and there's already an error overlay, it\n                // means the page opened with existing server compile error and the whole\n                // module script failed to load (since one of the nested imports is 500).\n                // in this case a normal update won't work and a full reload is needed.\n                if (isFirstUpdate && hasErrorOverlay()) {\n                    window.location.reload();\n                    return;\n                }\n                else {\n                    if (enableOverlay) {\n                        clearErrorOverlay();\n                    }\n                    isFirstUpdate = false;\n                }\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return hmrClient.queueUpdate(update);\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (hasDocument) {\n                if (payload.path && payload.path.endsWith('.html')) {\n                    // if html file is edited, only reload the page if the browser is\n                    // currently on that page.\n                    const pagePath = decodeURI(location.pathname);\n                    const payloadPath = base + payload.path.slice(1);\n                    if (pagePath === payloadPath ||\n                        payload.path === '/index.html' ||\n                        (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                        pageReload();\n                    }\n                    return;\n                }\n                else {\n                    pageReload();\n                }\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            await hmrClient.prunePaths(payload.paths);\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            if (hasDocument) {\n                const err = payload.err;\n                if (enableOverlay) {\n                    createErrorOverlay(err);\n                }\n                else {\n                    console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n                }\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    hmrClient.notifyListeners(event, data);\n}\nconst enableOverlay = true;\nconst hasDocument = 'document' in globalThis;\nfunction createErrorOverlay(err) {\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    const ping = async () => {\n        // A fetch on a websocket URL will return a successful promise with status 400,\n        // but will reject a networking error.\n        // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n        try {\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n                headers: {\n                    // Custom headers won't be included in a request with no-cors so (ab)use one of the\n                    // safelisted headers to identify the ping request\n                    Accept: 'text/x-vite-ping',\n                },\n            });\n            return true;\n        }\n        catch { }\n        return false;\n    };\n    if (await ping()) {\n        return;\n    }\n    await wait(ms);\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (document.visibilityState === 'visible') {\n            if (await ping()) {\n                break;\n            }\n            await wait(ms);\n        }\n        else {\n            await waitForWindowShow();\n        }\n    }\n}\nfunction wait(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n    return new Promise((resolve) => {\n        const onChange = async () => {\n            if (document.visibilityState === 'visible') {\n                resolve();\n                document.removeEventListener('visibilitychange', onChange);\n            }\n        };\n        document.addEventListener('visibilitychange', onChange);\n    });\n}\nconst sheetsMap = new Map();\n// collect existing style elements that may have been inserted during SSR\n// to avoid FOUC or duplicate styles\nif ('document' in globalThis) {\n    document\n        .querySelectorAll('style[data-vite-dev-id]')\n        .forEach((el) => {\n        sheetsMap.set(el.getAttribute('data-vite-dev-id'), el);\n    });\n}\nconst cspNonce = 'document' in globalThis\n    ? (_a = document.querySelector('meta[property=csp-nonce]')) === null || _a === void 0 ? void 0 : _a.nonce\n    : undefined;\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (cspNonce) {\n            style.setAttribute('nonce', cspNonce);\n        }\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nfunction createHotContext(ownerPath) {\n    return new HMRContext(hmrClient, ownerPath);\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (url[0] !== '.' && url[0] !== '/') {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/[?#].*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n                                   \n",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal",
            "sourcemaps": null
        },
        {
            "name": "vite:css-analysis",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal"
        },
        {
            "name": "vite:import-analysis",
            "result": "import \"/node_modules/.pnpm/vite@5.2.10_@types+node@20.5.1_less@4.2.0_sass@1.77.2/node_modules/vite/dist/client/env.mjs\";\n\nclass HMRContext {\n    constructor(hmrClient, ownerPath) {\n        this.hmrClient = hmrClient;\n        this.ownerPath = ownerPath;\n        if (!hmrClient.dataMap.has(ownerPath)) {\n            hmrClient.dataMap.set(ownerPath, {});\n        }\n        // when a file is hot updated, a new context is created\n        // clear its stale callbacks\n        const mod = hmrClient.hotModulesMap.get(ownerPath);\n        if (mod) {\n            mod.callbacks = [];\n        }\n        // clear stale custom event listeners\n        const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n        if (staleListeners) {\n            for (const [event, staleFns] of staleListeners) {\n                const listeners = hmrClient.customListenersMap.get(event);\n                if (listeners) {\n                    hmrClient.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n                }\n            }\n        }\n        this.newListeners = new Map();\n        hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n    }\n    get data() {\n        return this.hmrClient.dataMap.get(this.ownerPath);\n    }\n    accept(deps, callback) {\n        if (typeof deps === 'function' || !deps) {\n            // self-accept: hot.accept(() => {})\n            this.acceptDeps([this.ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n        }\n        else if (typeof deps === 'string') {\n            // explicit deps\n            this.acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        }\n        else if (Array.isArray(deps)) {\n            this.acceptDeps(deps, callback);\n        }\n        else {\n            throw new Error(`invalid hot.accept() usage.`);\n        }\n    }\n    // export names (first arg) are irrelevant on the client side, they're\n    // extracted in the server for propagation\n    acceptExports(_, callback) {\n        this.acceptDeps([this.ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n    }\n    dispose(cb) {\n        this.hmrClient.disposeMap.set(this.ownerPath, cb);\n    }\n    prune(cb) {\n        this.hmrClient.pruneMap.set(this.ownerPath, cb);\n    }\n    // Kept for backward compatibility (#11036)\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    decline() { }\n    invalidate(message) {\n        this.hmrClient.notifyListeners('vite:invalidate', {\n            path: this.ownerPath,\n            message,\n        });\n        this.send('vite:invalidate', { path: this.ownerPath, message });\n        this.hmrClient.logger.debug(`[vite] invalidate ${this.ownerPath}${message ? `: ${message}` : ''}`);\n    }\n    on(event, cb) {\n        const addToMap = (map) => {\n            const existing = map.get(event) || [];\n            existing.push(cb);\n            map.set(event, existing);\n        };\n        addToMap(this.hmrClient.customListenersMap);\n        addToMap(this.newListeners);\n    }\n    off(event, cb) {\n        const removeFromMap = (map) => {\n            const existing = map.get(event);\n            if (existing === undefined) {\n                return;\n            }\n            const pruned = existing.filter((l) => l !== cb);\n            if (pruned.length === 0) {\n                map.delete(event);\n                return;\n            }\n            map.set(event, pruned);\n        };\n        removeFromMap(this.hmrClient.customListenersMap);\n        removeFromMap(this.newListeners);\n    }\n    send(event, data) {\n        this.hmrClient.messenger.send(JSON.stringify({ type: 'custom', event, data }));\n    }\n    acceptDeps(deps, callback = () => { }) {\n        const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n            id: this.ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n    }\n}\nclass HMRMessenger {\n    constructor(connection) {\n        this.connection = connection;\n        this.queue = [];\n    }\n    send(message) {\n        this.queue.push(message);\n        this.flush();\n    }\n    flush() {\n        if (this.connection.isReady()) {\n            this.queue.forEach((msg) => this.connection.send(msg));\n            this.queue = [];\n        }\n    }\n}\nclass HMRClient {\n    constructor(logger, connection, \n    // This allows implementing reloading via different methods depending on the environment\n    importUpdatedModule) {\n        this.logger = logger;\n        this.importUpdatedModule = importUpdatedModule;\n        this.hotModulesMap = new Map();\n        this.disposeMap = new Map();\n        this.pruneMap = new Map();\n        this.dataMap = new Map();\n        this.customListenersMap = new Map();\n        this.ctxToListenersMap = new Map();\n        this.updateQueue = [];\n        this.pendingUpdateQueue = false;\n        this.messenger = new HMRMessenger(connection);\n    }\n    async notifyListeners(event, data) {\n        const cbs = this.customListenersMap.get(event);\n        if (cbs) {\n            await Promise.allSettled(cbs.map((cb) => cb(data)));\n        }\n    }\n    clear() {\n        this.hotModulesMap.clear();\n        this.disposeMap.clear();\n        this.pruneMap.clear();\n        this.dataMap.clear();\n        this.customListenersMap.clear();\n        this.ctxToListenersMap.clear();\n    }\n    // After an HMR update, some modules are no longer imported on the page\n    // but they may have left behind side effects that need to be cleaned up\n    // (.e.g style injections)\n    async prunePaths(paths) {\n        await Promise.all(paths.map((path) => {\n            const disposer = this.disposeMap.get(path);\n            if (disposer)\n                return disposer(this.dataMap.get(path));\n        }));\n        paths.forEach((path) => {\n            const fn = this.pruneMap.get(path);\n            if (fn) {\n                fn(this.dataMap.get(path));\n            }\n        });\n    }\n    warnFailedUpdate(err, path) {\n        if (!err.message.includes('fetch')) {\n            this.logger.error(err);\n        }\n        this.logger.error(`[hmr] Failed to reload ${path}. ` +\n            `This could be due to syntax errors or importing non-existent ` +\n            `modules. (see errors above)`);\n    }\n    /**\n     * buffer multiple hot updates triggered by the same src change\n     * so that they are invoked in the same order they were sent.\n     * (otherwise the order may be inconsistent because of the http request round trip)\n     */\n    async queueUpdate(payload) {\n        this.updateQueue.push(this.fetchUpdate(payload));\n        if (!this.pendingUpdateQueue) {\n            this.pendingUpdateQueue = true;\n            await Promise.resolve();\n            this.pendingUpdateQueue = false;\n            const loading = [...this.updateQueue];\n            this.updateQueue = [];\n            (await Promise.all(loading)).forEach((fn) => fn && fn());\n        }\n    }\n    async fetchUpdate(update) {\n        const { path, acceptedPath } = update;\n        const mod = this.hotModulesMap.get(path);\n        if (!mod) {\n            // In a code-splitting project,\n            // it is common that the hot-updating module is not loaded yet.\n            // https://github.com/vitejs/vite/issues/721\n            return;\n        }\n        let fetchedModule;\n        const isSelfUpdate = path === acceptedPath;\n        // determine the qualified callbacks before we re-import the modules\n        const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n        if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n            const disposer = this.disposeMap.get(acceptedPath);\n            if (disposer)\n                await disposer(this.dataMap.get(acceptedPath));\n            try {\n                fetchedModule = await this.importUpdatedModule(update);\n            }\n            catch (e) {\n                this.warnFailedUpdate(e, acceptedPath);\n            }\n        }\n        return () => {\n            for (const { deps, fn } of qualifiedCallbacks) {\n                fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n            }\n            const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n            this.logger.debug(`[vite] hot updated: ${loggedPath}`);\n        };\n    }\n}\n\nconst hmrConfigName = \"vite.config.ts\";\nconst base$1 = \"/\" || '/';\n// Create an element with provided attributes and optional children\nfunction h(e, attrs = {}, ...children) {\n    const elem = document.createElement(e);\n    for (const [k, v] of Object.entries(attrs)) {\n        elem.setAttribute(k, v);\n    }\n    elem.append(...children);\n    return elem;\n}\n// set :host styles to make playwright detect the element as visible\nconst templateStyle = /*css*/ `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\n// Error Template\nconst createTemplate = () => h('div', { class: 'backdrop', part: 'backdrop' }, h('div', { class: 'window', part: 'window' }, h('pre', { class: 'message', part: 'message' }, h('span', { class: 'plugin', part: 'plugin' }), h('span', { class: 'message-body', part: 'message-body' })), h('pre', { class: 'file', part: 'file' }), h('pre', { class: 'frame', part: 'frame' }), h('pre', { class: 'stack', part: 'stack' }), h('div', { class: 'tip', part: 'tip' }, 'Click outside, press ', h('kbd', {}, 'Esc'), ' key, or fix the code to dismiss.', h('br'), 'You can also disable this overlay by setting ', h('code', { part: 'config-option-name' }, 'server.hmr.overlay'), ' to ', h('code', { part: 'config-option-value' }, 'false'), ' in ', h('code', { part: 'config-file-name' }, hmrConfigName), '.')), h('style', {}, templateStyle));\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.appendChild(createTemplate());\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n        this.closeOnEsc = (e) => {\n            if (e.key === 'Escape' || e.code === 'Escape') {\n                this.close();\n            }\n        };\n        document.addEventListener('keydown', this.closeOnEsc);\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n        document.removeEventListener('keydown', this.closeOnEsc);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nvar _a;\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = \"localhost:undefined/\";\nconst socketProtocol = null || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:undefined/\";\nconst base = \"/\" || '/';\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n        notifyListeners('vite:ws:connect', { webSocket: socket });\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        notifyListeners('vite:ws:disconnect', { webSocket: socket });\n        if (hasDocument) {\n            console.log(`[vite] server connection lost. polling for restart...`);\n            await waitForSuccessfulPing(protocol, hostAndPath);\n            location.reload();\n        }\n    });\n    return socket;\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, 'http://vitejs.dev');\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nconst debounceReload = (time) => {\n    let timer;\n    return () => {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n        timer = setTimeout(() => {\n            location.reload();\n        }, time);\n    };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(console, {\n    isReady: () => socket && socket.readyState === 1,\n    send: (message) => socket.send(message),\n}, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport, }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n    /* @vite-ignore */\n    base +\n        acceptedPathWithoutQuery.slice(1) +\n        `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n    if (isWithinCircularImport) {\n        importPromise.catch(() => {\n            console.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. ` +\n                `To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n            pageReload();\n        });\n    }\n    return await importPromise;\n});\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            hmrClient.messenger.flush();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, 30000);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            if (hasDocument) {\n                // if this is the first update and there's already an error overlay, it\n                // means the page opened with existing server compile error and the whole\n                // module script failed to load (since one of the nested imports is 500).\n                // in this case a normal update won't work and a full reload is needed.\n                if (isFirstUpdate && hasErrorOverlay()) {\n                    window.location.reload();\n                    return;\n                }\n                else {\n                    if (enableOverlay) {\n                        clearErrorOverlay();\n                    }\n                    isFirstUpdate = false;\n                }\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return hmrClient.queueUpdate(update);\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (hasDocument) {\n                if (payload.path && payload.path.endsWith('.html')) {\n                    // if html file is edited, only reload the page if the browser is\n                    // currently on that page.\n                    const pagePath = decodeURI(location.pathname);\n                    const payloadPath = base + payload.path.slice(1);\n                    if (pagePath === payloadPath ||\n                        payload.path === '/index.html' ||\n                        (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                        pageReload();\n                    }\n                    return;\n                }\n                else {\n                    pageReload();\n                }\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            await hmrClient.prunePaths(payload.paths);\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            if (hasDocument) {\n                const err = payload.err;\n                if (enableOverlay) {\n                    createErrorOverlay(err);\n                }\n                else {\n                    console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n                }\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    hmrClient.notifyListeners(event, data);\n}\nconst enableOverlay = true;\nconst hasDocument = 'document' in globalThis;\nfunction createErrorOverlay(err) {\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    const ping = async () => {\n        // A fetch on a websocket URL will return a successful promise with status 400,\n        // but will reject a networking error.\n        // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n        try {\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n                headers: {\n                    // Custom headers won't be included in a request with no-cors so (ab)use one of the\n                    // safelisted headers to identify the ping request\n                    Accept: 'text/x-vite-ping',\n                },\n            });\n            return true;\n        }\n        catch { }\n        return false;\n    };\n    if (await ping()) {\n        return;\n    }\n    await wait(ms);\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (document.visibilityState === 'visible') {\n            if (await ping()) {\n                break;\n            }\n            await wait(ms);\n        }\n        else {\n            await waitForWindowShow();\n        }\n    }\n}\nfunction wait(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n    return new Promise((resolve) => {\n        const onChange = async () => {\n            if (document.visibilityState === 'visible') {\n                resolve();\n                document.removeEventListener('visibilitychange', onChange);\n            }\n        };\n        document.addEventListener('visibilitychange', onChange);\n    });\n}\nconst sheetsMap = new Map();\n// collect existing style elements that may have been inserted during SSR\n// to avoid FOUC or duplicate styles\nif ('document' in globalThis) {\n    document\n        .querySelectorAll('style[data-vite-dev-id]')\n        .forEach((el) => {\n        sheetsMap.set(el.getAttribute('data-vite-dev-id'), el);\n    });\n}\nconst cspNonce = 'document' in globalThis\n    ? (_a = document.querySelector('meta[property=csp-nonce]')) === null || _a === void 0 ? void 0 : _a.nonce\n    : undefined;\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (cspNonce) {\n            style.setAttribute('nonce', cspNonce);\n        }\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nfunction createHotContext(ownerPath) {\n    return new HMRContext(hmrClient, ownerPath);\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (url[0] !== '.' && url[0] !== '/') {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/[?#].*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n                                   \n",
            "start": 1725009516163,
            "end": 1725009516163,
            "order": "normal",
            "sourcemaps": null
        }
    ]
}
